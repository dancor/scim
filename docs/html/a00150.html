<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>scim: scim_slot.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>scim_slot.h File Reference</h1>C++ slot interface.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">scim::Slot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for slots that can connect to scim::Signals.  <a href="a00095.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">scim::Slot0&lt; R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing no arguments and returning a value of type R.  <a href="a00096.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">scim::FunctionSlot0&lt; R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking no arguments and returning a value of type R.  <a href="a00035.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">scim::MethodSlot0&lt; T, R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking no arguments and returning a value of type R.  <a href="a00056.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">scim::SignalSlot0&lt; T, R &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">scim::Slot1&lt; R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing one argument of type P1 and returning a value of type R.  <a href="a00097.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">scim::FunctionSlot1&lt; R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking one argument of type P1 and returning a value of type R.  <a href="a00036.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">scim::MethodSlot1&lt; T, R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking one argument of type P1 and returning a value of type R.  <a href="a00057.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">scim::SignalSlot1&lt; T, R, P1 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">scim::Slot2&lt; R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing two arguments of type P1 and P2, and returning a value of type R.  <a href="a00098.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">scim::FunctionSlot2&lt; R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking two arguments of type P1 and P2, and returning a value of type R.  <a href="a00037.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">scim::MethodSlot2&lt; T, R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking two arguments of type P1 and P2, and returning a value of type R.  <a href="a00058.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">scim::SignalSlot2&lt; T, R, P1, P2 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">scim::Slot3&lt; R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00099.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">scim::FunctionSlot3&lt; R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00038.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">scim::MethodSlot3&lt; T, R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00059.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">scim::SignalSlot3&lt; T, R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">scim::Slot4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00100.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">scim::FunctionSlot4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00039.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">scim::MethodSlot4&lt; T, R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00060.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">scim::SignalSlot4&lt; T, R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">scim::Slot5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00101.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">scim::FunctionSlot5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00040.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">scim::MethodSlot5&lt; T, R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00061.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">scim::SignalSlot5&lt; T, R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">scim::Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00102.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">scim::FunctionSlot6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00041.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">scim::MethodSlot6&lt; T, R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00062.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">scim::SignalSlot6&lt; T, R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">scim</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Slot functions returning a new slot</div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt; R &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g78b58e14a94be25909a5008abfe1836f">scim::slot</a> (R(*function)())</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt; R &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ge85d53489b114d64c39b0ad055056aec">scim::slot</a> (T1 *&amp;object, R(T2::*function)())</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt; R &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g8c4f6b824c67fdf1ce2960999c4b20c0">scim::slot</a> (T1 *const &amp;object, R(T2::*function)())</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot0&lt; R &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g2c1d8d66ad92f4caa7d810271a244cec">scim::slot</a> (T1 &amp;object, R(T2::*function)())</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R , typename P1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt; R, P1 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gc93d970869f273faf7b415ed88afdede">scim::slot</a> (R(*function)(P1))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt; R, P1 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gda1b495a0872a42a46f4fc642913c6c4">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt; R, P1 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g663227d085122e8bb0d96dbd194e5129">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot1&lt; R, P1 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ge21e10bc44924927f7a6b631b4c1218a">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R , typename P1 , typename P2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gffdca119b050b4b2c948950039fbe243">scim::slot</a> (R(*function)(P1, P2))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gae4f999260ec7a78cd199850f8afa6fe">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g4ffef51ac1d45832b923b29c17415c3c">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g8cc0f8891ed3da965fd5b7e00f32d7fd">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g340ef146ac4fcb85072b2d2aff62425a">scim::slot</a> (R(*function)(P1, P2, P3))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g889fc9877202da9dce8fbf393e19140d">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g58ada586377a157882084787f4eef0e0">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g9915184cc3b9069e740266ba913e76d8">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g76a5ba4df8c33fbdcf0bbfb4132b9d47">scim::slot</a> (R(*function)(P1, P2, P3, P4))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g3656a50ced90c4986f8e98c83df2544f">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g182fa472e5d2e1170c28503d10fcaded">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga65cc28d2c9a092b80644da78d74e41f">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3, P4))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga2c16e25f92368a471d08a9f36a944a5">scim::slot</a> (R(*function)(P1, P2, P3, P4, P5))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ge5040fda61635e60f70ac68f736cdf54">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4, P5))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g2875421e632a5667250cd4b5ca456191">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4, P5))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g885058a0f9cec690c37ac510a6ae4405">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3, P4, P5))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak">
P6 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gacd175f3e4e7660d3c8ed0b66063f2fa">scim::slot</a> (R(*function)(P1, P2, P3, P4, P5, P6))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak">
P6 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gcded5b9f054865d0ceb3596efb62d8a3">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak">
P6 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g10a5649f2d449283d9676fca712158e6">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak">
P6 &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#g714bb7fd0f0ca73233b571e402eefebe">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
C++ slot interface. 
<p>
Provides a set of slot class templates. Slots are callable objects that can be used to connect functions, class methods and function objects to scim::Signals.<p>
Most code of this file are came from Inti project. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 19 13:02:36 2009 for scim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
