<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>scim: SignalSlot</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SignalSlot</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">scim::BoundSlot0_1&lt; R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a slot taking one argument into a slot taking no arguments.  <a href="a00004.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">scim::BoundSlot1_2&lt; R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a slot taking two arguments into a slot taking one argument.  <a href="a00005.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">scim::BoundSlot2_3&lt; R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a slot taking three arguments into a slot taking two arguments.  <a href="a00006.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">scim::BoundSlot3_4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a slot taking four arguments into a slot taking three arguments.  <a href="a00007.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">scim::BoundSlot4_5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a slot taking five arguments into a slot taking four arguments.  <a href="a00008.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">scim::BoundSlot5_6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a slot taking six arguments into a slot taking five arguments.  <a href="a00009.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">scim::Node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for classes managing slots.  <a href="a00065.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">scim::Connection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A signal connection class.  <a href="a00017.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">scim::SlotNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A node class for managing slots connected to <a class="el" href="a00073.html" title="Base class for the C++ signal interface.">scim::Signal</a>'s.  <a href="a00103.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">scim::DefaultMarshal&lt; R &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">scim::DefaultMarshal&lt; bool &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">scim::Signal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for the C++ signal interface.  <a href="a00073.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">scim::Signal0&lt; R, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing no arguments and returning a value of type R.  <a href="a00074.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">scim::Signal0&lt; void, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">scim::Signal1&lt; R, P1, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing one argument of type P1 and returning a value of type R.  <a href="a00076.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">scim::Signal1&lt; void, P1, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">scim::Signal2&lt; R, P1, P2, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing two arguments of type P1 and P2, and returning a value of type R.  <a href="a00078.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">scim::Signal2&lt; void, P1, P2, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">scim::Signal3&lt; R, P1, P2, P3, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00080.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">scim::Signal3&lt; void, P1, P2, P3, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">scim::Signal4&lt; R, P1, P2, P3, P4, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00082.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">scim::Signal4&lt; void, P1, P2, P3, P4, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">scim::Signal5&lt; R, P1, P2, P3, P4, P5, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00084.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">scim::Signal5&lt; void, P1, P2, P3, P4, P5, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">scim::Signal6&lt; R, P1, P2, P3, P4, P5, P6, Marshal &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template for a signal passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00086.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">scim::Signal6&lt; void, P1, P2, P3, P4, P5, P6, IgnoreMarshal &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">scim::Slot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for slots that can connect to scim::Signals.  <a href="a00095.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">scim::Slot0&lt; R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing no arguments and returning a value of type R.  <a href="a00096.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">scim::FunctionSlot0&lt; R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking no arguments and returning a value of type R.  <a href="a00035.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">scim::MethodSlot0&lt; T, R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking no arguments and returning a value of type R.  <a href="a00056.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">scim::SignalSlot0&lt; T, R &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">scim::Slot1&lt; R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing one argument of type P1 and returning a value of type R.  <a href="a00097.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">scim::FunctionSlot1&lt; R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking one argument of type P1 and returning a value of type R.  <a href="a00036.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">scim::MethodSlot1&lt; T, R, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking one argument of type P1 and returning a value of type R.  <a href="a00057.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">scim::SignalSlot1&lt; T, R, P1 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">scim::Slot2&lt; R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing two arguments of type P1 and P2, and returning a value of type R.  <a href="a00098.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">scim::FunctionSlot2&lt; R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking two arguments of type P1 and P2, and returning a value of type R.  <a href="a00037.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">scim::MethodSlot2&lt; T, R, P1, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking two arguments of type P1 and P2, and returning a value of type R.  <a href="a00058.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">scim::SignalSlot2&lt; T, R, P1, P2 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">scim::Slot3&lt; R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00099.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">scim::FunctionSlot3&lt; R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00038.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">scim::MethodSlot3&lt; T, R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00059.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">scim::SignalSlot3&lt; T, R, P1, P2, P3 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">scim::Slot4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00100.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">scim::FunctionSlot4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00039.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">scim::MethodSlot4&lt; T, R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00060.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">scim::SignalSlot4&lt; T, R, P1, P2, P3, P4 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">scim::Slot5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00101.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">scim::FunctionSlot5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00040.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">scim::MethodSlot5&lt; T, R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00061.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">scim::SignalSlot5&lt; T, R, P1, P2, P3, P4, P5 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">scim::Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class template for slots passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00102.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">scim::FunctionSlot6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for static functions taking six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00041.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">scim::MethodSlot6&lt; T, R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slot template for methods in a class of type T taking six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00062.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">scim::SignalSlot6&lt; T, R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The classes for signal/slot mechanism. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gf19726cd2127175c4d22c7b446a7550f"></a><!-- doxytag: member="scim::bind" ref="gf19726cd2127175c4d22c7b446a7550f" args="(Slot1&lt; R, P1 &gt; *s, P1 p1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::bind           </td>
          <td>(</td>
          <td class="paramtype">Slot1&lt; R, P1 &gt; *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded <a class="el" href="a00159.html#gf19726cd2127175c4d22c7b446a7550f">bind()</a> factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- a slot of type Slot1&lt;R, P1&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>- a value of type P1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot that stores the value p1.</dd></dl>
<br>
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p1</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g2f7ab5e25879b2428aeda3e94554fd4c"></a><!-- doxytag: member="scim::bind" ref="g2f7ab5e25879b2428aeda3e94554fd4c" args="(Slot2&lt; R, P1, P2 &gt; *s, P2 p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::bind           </td>
          <td>(</td>
          <td class="paramtype">Slot2&lt; R, P1, P2 &gt; *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded <a class="el" href="a00159.html#gf19726cd2127175c4d22c7b446a7550f">bind()</a> factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- a slot of type Slot1&lt;R, P1, P2&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>- a value of type P2. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot that stores the value p2.</dd></dl>
<br>
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p2</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g616cb7206818b835a88dd5eabba50594"></a><!-- doxytag: member="scim::bind" ref="g616cb7206818b835a88dd5eabba50594" args="(Slot3&lt; R, P1, P2, P3 &gt; *s, P3 p3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::bind           </td>
          <td>(</td>
          <td class="paramtype">Slot3&lt; R, P1, P2, P3 &gt; *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded <a class="el" href="a00159.html#gf19726cd2127175c4d22c7b446a7550f">bind()</a> factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- a slot of type Slot1&lt;R, P1, P2, P3&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p3</em>&nbsp;</td><td>- a value of type P3. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot that stores the value p3.</dd></dl>
<br>
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p3</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g84b9c19585c4dee7cbc41e3eb6a82e54"></a><!-- doxytag: member="scim::bind" ref="g84b9c19585c4dee7cbc41e3eb6a82e54" args="(Slot4&lt; R, P1, P2, P3, P4 &gt; *s, P4 p4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::bind           </td>
          <td>(</td>
          <td class="paramtype">Slot4&lt; R, P1, P2, P3, P4 &gt; *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&nbsp;</td>
          <td class="paramname"> <em>p4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded <a class="el" href="a00159.html#gf19726cd2127175c4d22c7b446a7550f">bind()</a> factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- a slot of type Slot1&lt;R, P1, P2, P3, P4&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p4</em>&nbsp;</td><td>- a value of type P4. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot that stores the value p4.</dd></dl>
<br>
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p4</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gc8a8488f3daab2c3cc3bf90d4fe0822a"></a><!-- doxytag: member="scim::bind" ref="gc8a8488f3daab2c3cc3bf90d4fe0822a" args="(Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *s, P5 p5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::bind           </td>
          <td>(</td>
          <td class="paramtype">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P5&nbsp;</td>
          <td class="paramname"> <em>p5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded <a class="el" href="a00159.html#gf19726cd2127175c4d22c7b446a7550f">bind()</a> factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- a slot of type Slot1&lt;R, P1, P2, P3, P4, P5&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p5</em>&nbsp;</td><td>- a value of type P5. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot that stores the value p5.</dd></dl>
<br>
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p5</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g0d82da49ea95826f3184a740006c2bc2"></a><!-- doxytag: member="scim::bind" ref="g0d82da49ea95826f3184a740006c2bc2" args="(Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt; *s, P6 p6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::bind           </td>
          <td>(</td>
          <td class="paramtype">Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt; *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P6&nbsp;</td>
          <td class="paramname"> <em>p6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded <a class="el" href="a00159.html#gf19726cd2127175c4d22c7b446a7550f">bind()</a> factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- a slot of type Slot1&lt;R, P1, P2, P3, P4, P5, P6&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p6</em>&nbsp;</td><td>- a value of type P6. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot that stores the value p6.</dd></dl>
<br>
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p6</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g78b58e14a94be25909a5008abfe1836f"></a><!-- doxytag: member="scim::slot" ref="g78b58e14a94be25909a5008abfe1836f" args="(R(*function)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)()&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="ge85d53489b114d64c39b0ad055056aec"></a><!-- doxytag: member="scim::slot" ref="ge85d53489b114d64c39b0ad055056aec" args="(T1 *&amp;object, R(T2::*function)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)()&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g8c4f6b824c67fdf1ce2960999c4b20c0"></a><!-- doxytag: member="scim::slot" ref="g8c4f6b824c67fdf1ce2960999c4b20c0" args="(T1 *const &amp;object, R(T2::*function)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)()&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g2c1d8d66ad92f4caa7d810271a244cec"></a><!-- doxytag: member="scim::slot" ref="g2c1d8d66ad92f4caa7d810271a244cec" args="(T1 &amp;object, R(T2::*function)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)()&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gc93d970869f273faf7b415ed88afdede"></a><!-- doxytag: member="scim::slot" ref="gc93d970869f273faf7b415ed88afdede" args="(R(*function)(P1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1)&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(P1). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gda1b495a0872a42a46f4fc642913c6c4"></a><!-- doxytag: member="scim::slot" ref="gda1b495a0872a42a46f4fc642913c6c4" args="(T1 *&amp;object, R(T2::*function)(P1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g663227d085122e8bb0d96dbd194e5129"></a><!-- doxytag: member="scim::slot" ref="g663227d085122e8bb0d96dbd194e5129" args="(T1 *const &amp;object, R(T2::*function)(P1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="ge21e10bc44924927f7a6b631b4c1218a"></a><!-- doxytag: member="scim::slot" ref="ge21e10bc44924927f7a6b631b4c1218a" args="(T1 &amp;object, R(T2::*function)(P1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gffdca119b050b4b2c948950039fbe243"></a><!-- doxytag: member="scim::slot" ref="gffdca119b050b4b2c948950039fbe243" args="(R(*function)(P1, P2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2)&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(P1, P2). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gae4f999260ec7a78cd199850f8afa6fe"></a><!-- doxytag: member="scim::slot" ref="gae4f999260ec7a78cd199850f8afa6fe" args="(T1 *&amp;object, R(T2::*function)(P1, P2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g4ffef51ac1d45832b923b29c17415c3c"></a><!-- doxytag: member="scim::slot" ref="g4ffef51ac1d45832b923b29c17415c3c" args="(T1 *const &amp;object, R(T2::*function)(P1, P2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g8cc0f8891ed3da965fd5b7e00f32d7fd"></a><!-- doxytag: member="scim::slot" ref="g8cc0f8891ed3da965fd5b7e00f32d7fd" args="(T1 &amp;object, R(T2::*function)(P1, P2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g340ef146ac4fcb85072b2d2aff62425a"></a><!-- doxytag: member="scim::slot" ref="g340ef146ac4fcb85072b2d2aff62425a" args="(R(*function)(P1, P2, P3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3)&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(P1, P2, P3). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g889fc9877202da9dce8fbf393e19140d"></a><!-- doxytag: member="scim::slot" ref="g889fc9877202da9dce8fbf393e19140d" args="(T1 *&amp;object, R(T2::*function)(P1, P2, P3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g58ada586377a157882084787f4eef0e0"></a><!-- doxytag: member="scim::slot" ref="g58ada586377a157882084787f4eef0e0" args="(T1 *const &amp;object, R(T2::*function)(P1, P2, P3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g9915184cc3b9069e740266ba913e76d8"></a><!-- doxytag: member="scim::slot" ref="g9915184cc3b9069e740266ba913e76d8" args="(T1 &amp;object, R(T2::*function)(P1, P2, P3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g76a5ba4df8c33fbdcf0bbfb4132b9d47"></a><!-- doxytag: member="scim::slot" ref="g76a5ba4df8c33fbdcf0bbfb4132b9d47" args="(R(*function)(P1, P2, P3, P4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3, P4)&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(P1, P2, P3, P4). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g3656a50ced90c4986f8e98c83df2544f"></a><!-- doxytag: member="scim::slot" ref="g3656a50ced90c4986f8e98c83df2544f" args="(T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g182fa472e5d2e1170c28503d10fcaded"></a><!-- doxytag: member="scim::slot" ref="g182fa472e5d2e1170c28503d10fcaded" args="(T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="ga65cc28d2c9a092b80644da78d74e41f"></a><!-- doxytag: member="scim::slot" ref="ga65cc28d2c9a092b80644da78d74e41f" args="(T1 &amp;object, R(T2::*function)(P1, P2, P3, P4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="ga2c16e25f92368a471d08a9f36a944a5"></a><!-- doxytag: member="scim::slot" ref="ga2c16e25f92368a471d08a9f36a944a5" args="(R(*function)(P1, P2, P3, P4, P5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3, P4, P5)&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="ge5040fda61635e60f70ac68f736cdf54"></a><!-- doxytag: member="scim::slot" ref="ge5040fda61635e60f70ac68f736cdf54" args="(T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4, P5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g2875421e632a5667250cd4b5ca456191"></a><!-- doxytag: member="scim::slot" ref="g2875421e632a5667250cd4b5ca456191" args="(T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4, P5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g885058a0f9cec690c37ac510a6ae4405"></a><!-- doxytag: member="scim::slot" ref="g885058a0f9cec690c37ac510a6ae4405" args="(T1 &amp;object, R(T2::*function)(P1, P2, P3, P4, P5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gacd175f3e4e7660d3c8ed0b66063f2fa"></a><!-- doxytag: member="scim::slot" ref="gacd175f3e4e7660d3c8ed0b66063f2fa" args="(R(*function)(P1, P2, P3, P4, P5, P6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3, P4, P5, P6)&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a static function with the signature R (*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<br>
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="gcded5b9f054865d0ceb3596efb62d8a3"></a><!-- doxytag: member="scim::slot" ref="gcded5b9f054865d0ceb3596efb62d8a3" args="(T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5, P6)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g10a5649f2d449283d9676fca712158e6"></a><!-- doxytag: member="scim::slot" ref="g10a5649f2d449283d9676fca712158e6" args="(T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5, P6)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
<a class="anchor" name="g714bb7fd0f0ca73233b571e402eefebe"></a><!-- doxytag: member="scim::slot" ref="g714bb7fd0f0ca73233b571e402eefebe" args="(T1 &amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5, P6)&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded slot factory function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<br>
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 19 13:02:37 2009 for scim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
